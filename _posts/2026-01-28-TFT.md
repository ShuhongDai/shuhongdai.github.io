---
layout: post
title: TFT
date: 2026-01-28 00:38:10
description: A practical record of troubleshooting outbound network restrictions on Chinese cloud servers and enabling stable access to foreign academic resources.
tags: ["Networking", "Proxy", "SSH", "DevOps"]
tabs: true
# thumbnail: /assets/posts_img/2024-02-02/thumbnail.png
toc:
  sidebar: left
---

## Introduction

In earlier seasons of Teamfight Tactics, the card pool could be modeled in a relatively clean way as a shared and static random resource. Champions were preloaded into a global pool, access to that pool was conditioned primarily on player level, and strategic interaction emerged almost entirely through inventory competition. Within this framework, most balance issues could be addressed locally by tuning pool sizes or appearance probabilities, without altering the structure of the system itself. The introduction of [unlockable champions](https://teamfighttactics.leagueoflegends.com/en-us/news/game-updates/lore-and-legends-overview/) in the current season does not fit comfortably into this model, and treating it as a conventional probability adjustment risks missing what has actually changed.

At first glance, the mechanic appears straightforward. Players satisfy certain conditions, unlock specific champions, and those champions may then appear in their shops. Framed this way, the system looks like a simple expansion of available options. However, this interpretation becomes problematic as soon as one asks a more precise question: are these champions being added to the card pool, or is access to an existing pool being selectively granted? The distinction matters. Directly injecting dozens of new champions into a shared pool would create severe dilution effects, undermine competitive symmetry, and scale poorly across future seasons. For these reasons alone, a naive “add to pool” interpretation is difficult to reconcile with a stable long-term design.

The more coherent reading, and the one adopted in this post, is that the card pool itself remains conceptually intact, while the rules governing how individual players access it have been restructured. Unlocking a champion does not primarily change what exists in the pool, but how that champion is weighted, filtered, and surfaced during shop generation for a given player. In this sense, the innovation is not a new set of cards, but a new access layer that sits between players and a shared resource. The sections that follow focus on this layer, examining how unlockable champions and recent adjustments to four- and five-cost units can be understood as consequences of a single underlying architectural choice rather than isolated balance patches.

---

## The Access Control Layer in System Abstraction

In the classical TFT model, the card pool can be abstracted as a shared finite multiset:

$$
\mathcal{C} = {(c_1, n_1), (c_2, n_2), \dots}
$$

Here, $$ c_k $$ denotes a specific champion, while $$ n_k $$ denotes the remaining quantity of that champion in the pool.

When a player $ i $ refreshes their shop at level $$ \ell_i $$, the operation can be described as a conditional random sampling process:

$$
\text{Shop}_i \sim \text{Sample}\big(\mathcal{C} \mid \ell_i\big)
$$

The conditioning occurs exclusively at the cost-tier level, through predefined level probability tables. Individual champions within the same cost tier are otherwise symmetric.

The essential property of this model is that all players operate within the same probability space. Differences in outcomes arise only through inventory depletion caused by other players’ purchases.

Attempting to introduce unlockable champions directly into the model above leads to an immediate structural conflict. Unlock state $$ U_i $$ is a player-specific variable, while the sampling space $$ \mathcal{C} $$ is global and shared. Without an additional abstraction layer, these two elements cannot be composed in a coherent way.

This is precisely why two seemingly obvious approaches fail at the system level. Adding unlocked champions directly into the global pool undermines probability stability. Creating fully independent pools per player eliminates the competitive interaction that defines the game.

In short, the traditional model lacks the expressive capacity required to represent player-specific access constraints.

To preserve both a shared card pool and individualized unlock states, the system must introduce an intermediate layer. The pool itself cannot be sampled directly. Instead, what is sampled is a player-specific method of accessing the pool. I will refer to this layer as an access control layer. The pool remains global, but the path through which each player interacts with it becomes conditional.

Under this revised abstraction, a global shared pool still exists:

$$
\mathcal{C}_{\text{global}}
$$

However, the shop presented to player $$ i $$ is generated by:

$$
\text{Shop}*i \sim \text{Sample}\big(\mathcal{C}*{\text{global}},; w_i(\cdot)\big)
$$

Here, $$ w_i(c) \ge 0 $$ is a player-dependent weight function. It determines both whether a champion is visible to the player and how frequently it appears. This reframing leads to a crucial distinction. Unlocking does not alter the contents of the card pool. Instead, it modifies the weighting applied during sampling.

For each player $$ i $$, define an unlock set:

$$
U_i \subseteq \mathcal{C}_{\text{global}}
$$

The weight function can then be expressed as:

$$
w_i(c)=
\begin{cases}
0, & \text{if } c \text{ is unlockable and } c \notin U_i \\
\alpha_i(c), & \text{if } c \in U_i \\
1, & \text{if } c \text{ is a standard champion}
\end{cases}
$$

The term $$ \alpha_i(c) $$ represents a dynamically adjusted parameter. As will be discussed later, it supports mechanisms such as probability decay for ignored champions, compensation under competition, and suppression of uncontrolled three-star acquisition.

Viewed from an implementation perspective, a shop refresh can be described schematically as follows:

```python
function refresh_shop(player i):
    candidates = global_card_pool.remaining()
    weights = []

    for card c in candidates:
        weights[c] = base_weight(c, level_i) * access_weight(i, c)

    shop = weighted_sample(candidates, weights, slot_count)
    return shop
```
The function `base_weight` corresponds to the traditional level-based cost distribution. The function `access_weight` represents the newly introduced interface.

This design choice is important. All new mechanics are implemented through adjustments to `access_weight`, while the underlying pool structure remains untouched.

Official descriptions state that unlocked champions appear in the rightmost shop slot upon refresh. At a system level, this is unlikely to be a purely visual decision.

A more plausible interpretation is that shop generation is divided into multiple sampling stages. At least one slot is drawn from a subspace governed by a distinct weighting scheme, dedicated to unlockable champions. This interpretation aligns naturally with the access control abstraction and will be examined in detail in the next chapter.
---
